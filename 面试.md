## 1. Vue组件之间通信方式有哪些
vue是组件化开发框架，所以对于vue应用来说组件间的数据通信非常重要。 此题主要考查大家vue基本功，对于vue基础api运用熟练度。 另外一些边界知识如provide/inject/$attrs则提现了面试者的知识广度。

组件传参的各种方式
![image](imgs/%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82.png)

**思路分析：**
1. 总述知道的所有方式
2. 按组件关系阐述使用场景

**回答范例**
1. 组件通信常用方式有以下8种：
- props
- $emit/~~$on~~
- ~~$children~~/$parent
- $attrs/~~$listeners~~
- ref
- $root
- eventbus
- vuex
>注意vue3中废弃的几个API    
v3-migration.vuejs.org/breaking-ch…   
v3-migration.vuejs.org/breaking-ch…   
v3-migration.vuejs.org/breaking-ch…    

2. 根据组件之间关系讨论组件通信最为清晰有效
- 父子组件
  - ==props/$emit/$parent/ref/$attrs==
- 兄弟组件
  - ==$parent/$root/eventbus/vuex==
- 跨层级关系
  - ==eventbus/vuex/provide+inject==

## 2. v-if和v-for哪个优先级更高？
**思路分析**
1. 先给出结论
2. 为什么是这样的，说出细节
3. 哪些场景可能导致我们这样做，该怎么处理
4. 总结，拔高

**回答范例**
1. 实践中不应该把v-for和v-if放一起
2. 在**vue2中，v-for的优先级是高于v-if**，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件，哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表，这会比较浪费；另外需要注意的是在**vue3中则完全相反，v-if的优先级高于v-for**，所以v-if执行时，它调用的变量还不存在，就会导致异常
3. 通常有两种情况下导致我们这样做：
   - 为了过滤列表中的项目 (比如 ==v-for="user in users" v-if="user.isActive"==)。此时定义一个计算属性 (比如 ==activeUsers==)，让其返回过滤后的列表即可（比如==users.filter(u=>u.isActive)==）。
   - 为了避免渲染本应该被隐藏的列表 (比如 ==v-for="user in users" v-if="shouldShowUsers"==)。此时把 ==v-if== 移动至容器元素上 (比如 ==ul、ol==)或者外面包一层==template==即可。
4. 文档中明确指出永远不要把**v-if**和 **v-for**同时用在同一个元素上，显然这是一个重要的注意事项。

**源码中找答案**
> v2：github1s.com/vuejs/vue/b…      
> v3：github1s.com/vuejs/core/…

## 3. 双向绑定使用和原理
**思路分析：**
1. 给出双绑定义
2. 双绑带来的好处
3. 在哪使用双绑
4. 使用方式、使用细节、vue3变化
5. 原理实现描述

**回答范例**
1. vue中双向绑定是一个指令==v-model==，可以绑定一个响应式数据到视图，同时视图中变化能改变该值。
2. ==v-model==是语法糖，默认情况下相当于 ==:value== 和 ==@input==。使用 ==v-model== 可以减少大量繁琐的事件处理代码，提高开发效率。
3. 通常在表单项上使用 ==v-model==，还可以在自定义组件上使用，表示某个值的输入和输出控制。
4. 通过 ==<input v-model="xxx">== 的方式将xxx的值绑定到表单元素value上；对于checkbox，可以使用 ==true-value== 和false-value指定特殊的值，对于radio可以使用value指定特殊的值；对于select可以通过options元素的value设置特殊的值；还可以结合.lazy,.number,.trim对v-mode的行为做进一步限定；v-model用在自定义组件上时又会有很大不同，vue3中它类似于==sync==修饰符，最终展开的结果是modelValue属性和update:modelValue事件；vue3中我们甚至可以用参数形式指定多个不同的绑定，例如v-model:foo和v-model:bar，非常强大！
5. ==v-model==是一个指令，它的神奇魔法实际上是vue的编译器完成的。我做过测试，包含v-model的模板，转换为渲染函数之后，实际上还是是value属性的绑定以及input事件监听，事件回调函数中会做相应变量更新操作。编译器根据表单元素的不同会展开不同的DOM属性和事件对，比如text类型的input和textarea会展开为value和input事件；checkbox和radio类型的input会展开为checked和change事件；select用value作为属性，用change作为事件。

**可能的追问：**
1. ==v-model==和==sync==修饰符有什么区别
2. 自定义组件使用v-model如果想要改变事件名或者属性名应该怎么做

## 4.如何拓展一个组件
此题属于实践题，考察大家对vue常用api使用熟练度，答题时不仅要列出这些解决方案，同时最好说出他们异同。

**答题思路**
1. 按照逻辑扩展和内容扩展来列举，
    - 逻辑扩展有：mixins、extends、composition api；
    - 内容扩展有slots；
2. 分别说出他们使用方法、场景差异和问题。
3. 作为扩展，还可以说说vue3中新引入的composition api带来的变化

**回答范例**
1. 常见的组件扩展方法有：mixins，slots，extends等
2. 混入mixins是分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。

```
// 复用代码：它是一个配置对象，选项和组件里面一样
const mymixin = {
   methods: {
      dosomething(){}
   }
}
// 全局混入：将混入对象传入
Vue.mixin(mymixin)

// 局部混入：做数组项设置到mixins选项，仅作用于当前组件
const Comp = {
   mixins: [mymixin]
}
```
3. 插槽主要用于vue组件中的内容分发，也可以用于组件扩展。

子组件Child
```html
<div>
  <slot>这个内容会被父组件传递的内容替换</slot>
</div>
```
父组件Parent
```html
<div>
   <Child>来自老爹的内容</Child>
</div>
```
> 如果要精确分发到不同位置可以使用具名插槽，如果要使用子组件中的数据可以使用作用域插槽。

4. 组件选项中还有一个不太常用的选项extends，也可以起到扩展组件的目的
```
// 扩展对象
const myextends = {
   methods: {
      dosomething(){}
   }
}
// 组件扩展：做数组项设置到extends选项，仅作用于当前组件
// 跟混入的不同是它只能扩展单个对象
// 另外如果和混入发生冲突，该选项优先级较高，优先起作用
const Comp = {
   extends: myextends
}
```
5. 混入的数据和方法不能明确判断来源且可能和当前组件内变量产生命名冲突，vue3中引入的composition api，可以很好解决这些问题，利用独立出来的响应式模块可以很方便的编写独立逻辑并提供响应式的数据，然后在setup选项中组合使用，增强代码的可读性和维护性。例如：
```
// 复用逻辑1
function useXX() {}
// 复用逻辑2
function useYY() {}
// 逻辑组合
const Comp = {
   setup() {
      const {xx} = useXX()
      const {yy} = useYY()
      return {xx, yy}
   }
}
```
**知其所以然**
mixins原理：
github1s.com/vuejs/core/…
github1s.com/vuejs/core/…   
slots原理：    
github1s.com/vuejs/core/…
github1s.com/vuejs/core/…
github1s.com/vuejs/core/…

## 5. Vue要做权限管理该怎么做？控制到按钮级别的权限怎么做？
**分析**

综合实践题目，实际开发中经常需要面临权限管理的需求，考查实际应用能力。

权限管理一般需求是两个：页面权限和按钮权限，从这两个方面论述即可。

**思路**

1. 权限管理需求分析：页面和按钮权限
2. 权限管理的实现方案：分后端方案和前端方案阐述
3. 说说各自的优缺点

**回答范例**

1. 权限管理一般需求是**页面权限**和**按钮权限**的管理
2. 具体实现的时候分后端和前端两种方案：
   - 前端方案会把**所有路由信息在前端配置**，通过路由守卫要求用户登录，用户登录后根据角色**过滤出路由表**。比如我会配置一个==asyncRoutes==数组，需要认证的页面在其路由的==meta==中添加一个==roles==字段，等获取用户角色之后取两者的交集，若结果不为空则说明可以访问。此过滤过程结束，剩下的路由就是该用户能访问的页面，最后通过 ==router.addRoutes(accessRoutes)== 方式**动态添加路由**即可。
   - 后端方案会**把所有页面路由信息存在数据库中**，用户登录的时候根据其角色**查询得到其能访问的所有页面路由信息**返回给前端，前端再通过==addRoutes==**动态添加路由**信息
   - 按钮权限的控制通常会**实现一个指令**，例如==v-permission==，**将按钮要求角色通过值传给v-permission指令**，在指令的==moutned==钩子中可以**判断当前用户角色和按钮是否存在交集**，有则保留按钮，无则移除按钮。
3. 纯前端方案的优点是实现简单，不需要额外权限管理页面，但是维护起来问题比较大，有新的页面和角色需求就要修改前端代码重新打包部署；服务端方案就不存在这个问题，通过专门的角色和权限管理页面，配置页面和按钮权限信息到数据库，应用每次登陆时获取的都是最新的路由信息，可谓一劳永逸！

**知其所以然**

路由守卫   
github1s.com/PanJiaChen/…  
路由生成  
github1s.com/PanJiaChen/…  
动态追加路由  
github1s.com/PanJiaChen/…
